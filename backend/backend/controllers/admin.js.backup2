const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { User, Upload, Questionnaire } = require('../models');
const { Op } = require('sequelize');

// Admin login controller (keeping existing - it works)
const adminLogin = async (req, res) => {
  try {
    const { email, password } = req.body;
    console.log("=== ADMIN LOGIN DEBUG ===");
    console.log("Email received:", email);
    console.log("Password received:", JSON.stringify(password));

    // Find user by email
    const user = await User.findOne({ 
      where: { 
        email,
        role: 'admin' // Only allow users with admin role to login
      } 
    });

    if (!user) {
      return res.status(401).json({
        error: 'Admin login failed',
        message: 'Invalid admin credentials'
      });
    }

    // Verify password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    console.log("Direct bcrypt comparison result:", isPasswordValid);
    if (!isPasswordValid) {
      return res.status(401).json({
        error: 'Admin login failed',
        message: 'Invalid admin credentials'
      });
    }

    // Generate admin JWT token with admin role claim
    const token = jwt.sign(
      { 
        id: user.id,
        email: user.email,
        role: 'admin'
      },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Return admin user data and token
    res.status(200).json({
      message: 'Admin login successful',
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role
      },
      token
    });
  } catch (error) {
    console.error('Admin login error:', error);
    res.status(500).json({
      error: 'Admin login failed',
      message: 'An error occurred during admin login'
    });
  }
};

// Get all candidates (keeping existing - it works)
const getAllCandidates = async (req, res) => {
  try {
    const candidates = await User.findAll({
      where: {
        role: { [Op.ne]: 'admin' }
      },
      attributes: ['id', 'firstName', 'lastName', 'email', 'phone', 'onboardingStep', 'onboardingCompleted', 'createdAt'],
      order: [['createdAt', 'DESC']]
    });

    res.status(200).json({
      candidates
    });
  } catch (error) {
    console.error('Get candidates error:', error);
    res.status(500).json({
      error: 'Failed to retrieve candidates',
      message: 'An error occurred while retrieving candidates'
    });
  }
};

// Get candidate details by ID (keeping existing - it works)
const getCandidateById = async (req, res) => {
  try {
    const { id } = req.params;
    
    const candidate = await User.findOne({
      where: {
        id,
        role: { [Op.ne]: 'admin' }
      },
      include: [
        {
          model: Upload,
          as: 'uploads'
        },
        {
          model: Questionnaire,
          as: 'questionnaire'
        }
      ]
    });

    if (!candidate) {
      return res.status(404).json({
        error: 'Candidate not found',
        message: 'The requested candidate could not be found'
      });
    }

    res.status(200).json({
      candidate
    });
  } catch (error) {
    console.error('Get candidate error:', error);
    res.status(500).json({
      error: 'Failed to retrieve candidate',
      message: 'An error occurred while retrieving candidate details'
    });
  }
};

// FIXED: Dashboard statistics with proper debugging
const getDashboardStats = async (req, res) => {
  try {
    console.log('=== DASHBOARD STATS DEBUG ===');
    
    // Total candidates (non-admin users)
    const totalCandidates = await User.count({
      where: {
        role: { [Op.ne]: 'admin' }
      }
    });
    console.log('Total Candidates:', totalCandidates);

    // Completed onboarding - users who reached completion step
    const completedOnboarding = await User.count({
      where: {
        onboardingStep: 'completion',
        role: { [Op.ne]: 'admin' }
      }
    });
    console.log('Completed Onboarding (completion step):', completedOnboarding);

    // Alternative: users with onboardingCompleted flag
    const completedOnboardingFlag = await User.count({
      where: {
        onboardingCompleted: true,
        role: { [Op.ne]: 'admin' }
      }
    });
    console.log('Completed Onboarding (flag):', completedOnboardingFlag);

    // Submitted questionnaires - count all questionnaires
    const submittedQuestionnaires = await Questionnaire.count();
    console.log('Submitted Questionnaires:', submittedQuestionnaires);

    // Recent candidates (last 7 days)
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    
    const recentCandidates = await User.count({
      where: {
        createdAt: {
          [Op.gte]: sevenDaysAgo
        },
        role: { [Op.ne]: 'admin' }
      }
    });
    console.log('Recent Candidates (7d):', recentCandidates);

    // Onboarding steps distribution with debugging
    const welcomeStep = await User.count({ 
      where: { 
        onboardingStep: 'welcome',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Welcome Step:', welcomeStep);

    const photoStep = await User.count({ 
      where: { 
        onboardingStep: 'photo-upload',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Photo Step:', photoStep);

    const audioStep = await User.count({ 
      where: { 
        onboardingStep: 'audio-recording',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Audio Step:', audioStep);

    const videoStep = await User.count({ 
      where: { 
        onboardingStep: 'video-recording',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Video Step:', videoStep);

    const questionnaireStep = await User.count({ 
      where: { 
        onboardingStep: 'questionnaire',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Questionnaire Step:', questionnaireStep);

    const completionStep = await User.count({ 
      where: { 
        onboardingStep: 'completion',
        role: { [Op.ne]: 'admin' }
      } 
    });
    console.log('Completion Step:', completionStep);

    // Calculate percentages for progress bars
    const totalForPercentage = totalCandidates || 1; // Avoid division by zero
    
    console.log('=== END DASHBOARD STATS DEBUG ===');

    // FIXED: Return data structure that matches frontend expectations
    res.status(200).json({
      totalCandidates,
      completedOnboarding: Math.max(completedOnboarding, completedOnboardingFlag), // Use the higher value
      submittedQuestionnaires,
      recentCandidates,
      onboardingSteps: {
        welcome: welcomeStep,
        photoUpload: photoStep,
        audioRecording: audioStep,
        videoRecording: videoStep,
        questionnaire: questionnaireStep,
        completion: completionStep
      },
      // Add percentage calculations for progress bars
      onboardingProgress: {
        welcome: Math.round((welcomeStep / totalForPercentage) * 100),
        photoUpload: Math.round((photoStep / totalForPercentage) * 100),
        audioRecording: Math.round((audioStep / totalForPercentage) * 100),
        videoRecording: Math.round((videoStep / totalForPercentage) * 100),
        questionnaire: Math.round((questionnaireStep / totalForPercentage) * 100),
        completion: Math.round((completionStep / totalForPercentage) * 100)
      },
      message: 'Dashboard stats loaded successfully'
    });
  } catch (error) {
    console.error('Dashboard stats error:', error);
    res.status(500).json({
      error: 'Failed to retrieve dashboard statistics',
      message: 'An error occurred while retrieving dashboard statistics'
    });
  }
};

// FIXED: Get all questionnaires with proper user association and status
const getAllQuestionnaires = async (req, res) => {
  try {
    console.log('=== QUESTIONNAIRES DEBUG ===');
    
    const questionnaires = await Questionnaire.findAll({
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'firstName', 'lastName', 'email'],
          required: false // LEFT JOIN to include questionnaires even if user association fails
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    console.log('Found questionnaires:', questionnaires.length);
    
    const formattedQuestionnaires = questionnaires.map(q => {
      const candidateName = q.user ? 
        `${q.user.firstName || ''} ${q.user.lastName || ''}`.trim() : 
        'Unknown User';
      
      console.log(`Questionnaire ${q.id}: candidate=${candidateName}, completed=${q.completed}, submittedAt=${q.submittedAt}`);
      
      return {
        id: q.id,
        title: `Questionnaire #${q.id.substring(0, 8)}...`, // Show first 8 chars of UUID
        candidateName,
        candidate_name: candidateName,
        status: q.submittedAt ? 'COMPLETED' : 'PENDING', // Use submittedAt to determine status
        created_at: q.createdAt,
        createdAt: q.createdAt,
        submittedAt: q.submittedAt,
        userId: q.userId,
        personalInfo: q.personalInfo,
        contactInfo: q.contactInfo,
        workExperience: q.workExperience,
        references: q.references,
        additionalInfo: q.additionalInfo,
        consents: q.consents
      };
    });

    console.log('=== END QUESTIONNAIRES DEBUG ===');

    res.status(200).json({
      questionnaires: formattedQuestionnaires
    });
  } catch (error) {
    console.error('Get questionnaires error:', error);
    res.status(500).json({
      error: 'Failed to retrieve questionnaires',
      message: 'An error occurred while retrieving questionnaires'
    });
  }
};

// Get questionnaire by ID with full details
const getQuestionnaireById = async (req, res) => {
  try {
    const { id } = req.params;
    
    const questionnaire = await Questionnaire.findOne({
      where: { id },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'firstName', 'lastName', 'email'],
          required: false
        }
      ]
    });

    if (!questionnaire) {
      return res.status(404).json({
        error: 'Questionnaire not found',
        message: 'The requested questionnaire could not be found'
      });
    }

    const candidateName = questionnaire.user ? 
      `${questionnaire.user.firstName || ''} ${questionnaire.user.lastName || ''}`.trim() : 
      'Unknown User';

    res.status(200).json({
      questionnaire: {
        id: questionnaire.id,
        candidateName,
        status: questionnaire.submittedAt ? 'COMPLETED' : 'PENDING',
        createdAt: questionnaire.createdAt,
        submittedAt: questionnaire.submittedAt,
        personalInfo: questionnaire.personalInfo,
        contactInfo: questionnaire.contactInfo,
        workExperience: questionnaire.workExperience,
        references: questionnaire.references,
        additionalInfo: questionnaire.additionalInfo,
        consents: questionnaire.consents,
        user: questionnaire.user
      }
    });
  } catch (error) {
    console.error('Get questionnaire error:', error);
    res.status(500).json({
      error: 'Failed to retrieve questionnaire',
      message: 'An error occurred while retrieving questionnaire details'
    });
  }
};

// FIXED: Get all audio recordings with proper debugging
const getAllAudioRecordings = async (req, res) => {
  try {
    console.log('=== AUDIO RECORDINGS DEBUG ===');
    
    // First, let's see all uploads
    const allUploads = await Upload.findAll({
      attributes: ['id', 'type', 'userId', 'url', 'createdAt'],
      order: [['createdAt', 'DESC']]
    });
    console.log('All uploads:', allUploads.length);
    console.log('Upload types:', allUploads.map(u => u.type));

    // Now get audio recordings specifically
    const audioRecordings = await Upload.findAll({
      where: {
        type: 'audio'
      },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'firstName', 'lastName', 'email'],
          required: false // LEFT JOIN to include recordings even if user association fails
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    console.log('Audio recordings found:', audioRecordings.length);

    const formattedAudio = audioRecordings.map(a => {
      const candidateName = a.user ? 
        `${a.user.firstName || ''} ${a.user.lastName || ''}`.trim() : 
        'Unknown User';
      
      console.log(`Audio ${a.id}: candidate=${candidateName}, url=${a.url}, duration=${a.duration}`);
      
      return {
        id: a.id,
        title: `Audio Recording #${a.id.substring(0, 8)}...`, // Show first 8 chars of UUID
        description: 'Audio recording from candidate onboarding',
        file_url: a.url,
        url: a.url,
        duration: a.duration,
        file_size: a.metadata?.size,
        status: a.completed ? 'COMPLETED' : 'PENDING',
        created_at: a.createdAt,
        createdAt: a.createdAt,
        uploadedAt: a.uploadedAt,
        candidateName,
        candidate_name: candidateName,
        userId: a.userId,
        attempts: a.attempts
      };
    });

    console.log('=== END AUDIO RECORDINGS DEBUG ===');

    res.status(200).json({
      audio: formattedAudio,
      recordings: formattedAudio // Alternative key name
    });
  } catch (error) {
    console.error('Get audio recordings error:', error);
    res.status(500).json({
      error: 'Failed to retrieve audio recordings',
      message: 'An error occurred while retrieving audio recordings'
    });
  }
};

// Get all videos (keeping existing logic)
const getAllVideos = async (req, res) => {
  try {
    const videoRecordings = await Upload.findAll({
      where: {
        type: 'video'
      },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['firstName', 'lastName', 'email'],
          required: false
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    const formattedVideos = videoRecordings.map(v => ({
      id: v.id,
      title: `Video Recording #${v.id.substring(0, 8)}...`,
      description: 'Video recording from candidate onboarding',
      file_url: v.url,
      duration: v.duration,
      file_size: v.metadata?.size,
      status: v.completed ? 'completed' : 'pending',
      created_at: v.createdAt,
      candidateName: v.user ? `${v.user.firstName || ''} ${v.user.lastName || ''}`.trim() : 'Unknown User',
      candidate_name: v.user ? `${v.user.firstName || ''} ${v.user.lastName || ''}`.trim() : 'Unknown User'
    }));

    res.status(200).json({
      videos: formattedVideos
    });
  } catch (error) {
    console.error('Get videos error:', error);
    res.status(500).json({
      error: 'Failed to retrieve videos',
      message: 'An error occurred while retrieving videos'
    });
  }
};

// Get all photos (keeping existing logic)
const getAllPhotos = async (req, res) => {
  try {
    const photoUploads = await Upload.findAll({
      where: {
        type: 'photo'
      },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['firstName', 'lastName', 'email'],
          required: false
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    const formattedPhotos = photoUploads.map(p => ({
      id: p.id,
      title: `Photo Upload #${p.id.substring(0, 8)}...`,
      description: 'Photo upload from candidate onboarding',
      file_url: p.url,
      file_size: p.metadata?.size,
      status: p.completed ? 'completed' : 'pending',
      created_at: p.createdAt,
      candidateName: p.user ? `${p.user.firstName || ''} ${p.user.lastName || ''}`.trim() : 'Unknown User',
      candidate_name: p.user ? `${p.user.firstName || ''} ${p.user.lastName || ''}`.trim() : 'Unknown User'
    }));

    res.status(200).json({
      photos: formattedPhotos
    });
  } catch (error) {
    console.error('Get photos error:', error);
    res.status(500).json({
      error: 'Failed to retrieve photos',
      message: 'An error occurred while retrieving photos'
    });
  }
};

// Placeholder functions for CRUD operations (keeping existing)
const createQuestionnaire = async (req, res) => {
  res.status(501).json({ message: 'Create questionnaire not implemented' });
};

const updateQuestionnaire = async (req, res) => {
  res.status(501).json({ message: 'Update questionnaire not implemented' });
};

const deleteQuestionnaire = async (req, res) => {
  res.status(501).json({ message: 'Delete questionnaire not implemented' });
};

const approveCandidate = async (req, res) => {
  res.status(501).json({ message: 'Approve candidate not implemented' });
};

const rejectCandidate = async (req, res) => {
  res.status(501).json({ message: 'Reject candidate not implemented' });
};

module.exports = {
  adminLogin,
  getAllCandidates,
  getCandidateById,
  getDashboardStats,
  approveCandidate,
  rejectCandidate,
  getAllQuestionnaires,
  getQuestionnaireById,
  createQuestionnaire,
  updateQuestionnaire,
  deleteQuestionnaire,
  getAllVideos,
  getAllPhotos,
  getAllAudioRecordings
};
